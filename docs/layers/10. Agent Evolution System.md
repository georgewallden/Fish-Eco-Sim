# 10. Agent Evolution System - Design Document

**Version:** 2 (Revised for Alpha Roadmap Alignment)
**Last Updated:** 5/10/2025

---

## 1. Overview & Purpose

*   The Agent Evolution System (AES), implemented primarily in **Python**, implements mechanisms for evolving agent traits and/or behavioral strategies (e.g., neural network parameters, AI hyperparameters) over successive generations. It uses principles inspired by biological evolution, with Genetic Algorithms (GAs) being a core methodology.
*   Its primary role is to iteratively refine populations of agent "genomes." This involves: creating populations, orchestrating their evaluation by running simulations (via the Experiment Management System), assessing their "fitness" based on performance data (from the Statistical Analysis Layer processing logs from the Logging Layer), and then applying evolutionary operators (selection, crossover, mutation) to produce new, potentially better-adapted generations.
*   Key goals include: enabling the emergence of complex and adaptive agent behaviors, exploring the design space of possible agent characteristics, facilitating research into evolutionary dynamics, and creating a system where agents can co-evolve with each other and their environment within the Fish Eco Sim.

---

## 2. Core Components & Functionality (Targeted for Alpha PoC `a0.9.Y.Z` for basic GA)

*   **Genome Definition & Representation (Target: `a0.9.1.Z`):**
    *   Defines the structure of an agent's "genome," which encodes its heritable characteristics.
    *   **Genome can include parameters for:**
        *   **Physical Traits (for the Rust Simulation Layer):** E.g., `max_energy`, `vision_range`, `move_cost`, `size`, `color_for_camouflage`, `optimal_depth_preference`, `pressure_adaptation_trait`. These are typically represented as real-valued or discrete numbers within the genome.
        *   **Behavioral/AI Traits (for the Python Agent Intelligence Layer):** This could range from:
            *   Hyperparameters for a DRL agent (e.g., learning rate, discount factor, exploration decay rate).
            *   Initial weights for a fixed neural network architecture (more advanced neuroevolution).
            *   Parameters defining simpler rule-based or state-machine behaviors (if applicable).
    *   Representation: Likely a Python list or NumPy array of numbers (genes).
*   **Population Management (Target: `a0.9.2.Z` for initialization, ongoing in `a0.9.4.Z`):**
    *   Maintains the current population of genomes.
    *   Handles initialization of the first generation (e.g., random genomes within defined bounds, or from a base template genome).
*   **Fitness Evaluation Orchestration (Target: `a0.9.2.Z`):**
    *   For each individual genome in the current population:
        1.  **Translate Genome to Agent Configuration:** Convert the genome into a concrete agent configuration dictionary/object. This configuration will contain parameters for both the Rust Simulation Layer (physical traits) and the Python Agent Intelligence Layer (behavioral/AI traits). This step often involves mapping raw gene values to valid trait ranges and types.
        2.  **Schedule Simulation Runs:** Use the **Experiment Management System (`a0.6.Y.Z`)** to create an experiment plan and execute one or more simulation runs for agents defined by this configuration. Running multiple replicates per genome (with different Random Number Generator seeds) is crucial for robust fitness assessment.
        3.  The `simulation_id`(s) generated by the Experiment Management System for these evaluation runs are associated with the genome.
*   **Fitness Calculation (Interface with Analysis Layer - Target: `a0.9.2.Z`):**
    *   After simulation runs for a genome are complete, the Agent Evolution System queries/invokes the **Statistical Interpretation / Analysis Layer**.
    *   The Analysis Layer processes the logged Apache Parquet data (from the Logging Layer `a0.7.Y.Z`) for the relevant `simulation_id`(s) to compute one or more fitness scores.
    *   **Fitness Function(s):** These are defined by the user/researcher via configuration. Examples: Average lifespan, total energy accumulated, number of food items eaten, survival duration in challenging scenarios.
*   **Evolutionary Operators (Genetic Algorithm Core - Target: `a0.9.3.Z`):**
    *   **Selection:** Chooses parent genomes from the current population based on their fitness scores (e.g., tournament selection, roulette wheel).
    *   **Crossover (Recombination):** (Optional for basic Alpha GA) Combines genetic material from parent genomes to create offspring (e.g., single-point, uniform crossover).
    *   **Mutation:** Introduces small, random changes into offspring genomes (e.g., Gaussian perturbation for numeric genes).
*   **Generational Loop (Target: `a0.9.4.Z`):**
    *   The main control loop that iterates through generations: Initialize Population -> Evaluate Fitness -> Select Parents -> Create Offspring (Crossover & Mutation) -> Replace Population. Repeats for a configured number of generations or until a stopping criterion is met.
*   **Parameterization:** The Genetic Algorithm itself has configurable parameters (population size, mutation rate, crossover rate, selection method, number of generations).

---

## 3. Key Technologies & Patterns

*   **Primary Language(s):** Python
*   **Key Libraries/Frameworks (Anticipated for Alpha):**
    *   `NumPy` (for numerical operations on genomes if represented as arrays).
    *   Python's `random` module (for selection, mutation).
    *   (Future Beta) Specialized Evolutionary Computation libraries like `DEAP`, `PyGAD` if more complex GA features are needed.
    *   `PyYAML` (for loading its own operational configuration).
    *   Client code (Python) to interact with the Experiment Management System (which in turn calls the Go Orchestration Layer via gRPC).
    *   Client code or function calls to invoke the Statistical Interpretation / Analysis Layer's fitness calculation routines.
*   **Architectural Patterns Used:**
    *   Genetic Algorithm.
    *   Evolutionary Loop / Iterative Refinement.
    *   Population-based Search.
*   **Data Formats Handled (Internal):** Python lists/NumPy arrays for genomes, dictionaries for population data and agent configurations.

---

## 4. Interactions & Interfaces (Focus on Alpha `a0.9.Y.Z` integration)

*   **Interaction with Experiment Management System (`a0.6.Y.Z`):**
    *   **Submits:** Experiment plans (or instructs the EMS to generate them based on genome-derived configurations) to run batches of simulation evaluations. The AES provides the specific agent configurations (physical traits for Rust Simulation Layer, AI parameters for Python Agent Intelligence Layer) derived from each genome.
*   **Interaction with Statistical Interpretation / Analysis Layer (`a0.X_Analysis`):**
    *   **Requests/Invokes:** Fitness calculation routines, providing the `simulation_id`(s) corresponding to a genome's evaluation runs.
    *   **Receives:** Fitness scores for each evaluated genome.
*   **Interaction with Configuration Management System (`a0.1.Y.Z`, `a0.11.Y.Z`):**
    *   **Reads:** Its own operational parameters (population size, mutation/crossover rates, selection strategy, choice of fitness function, bounds for gene values) from YAML configuration files.
    *   **Reads:** Base templates or constraints for genome structure and initial agent configurations.
*   **Interaction with Logging Layer (`a0.7.Y.Z` - Indirectly):**
    *   Relies on the Logging Layer having captured comprehensive data from all simulation runs, as this data (in Apache Parquet format) is the input for the Statistical Interpretation / Analysis Layer to calculate fitness.
    *   The Agent Evolution System itself will log its own progress (e.g., generation number, best/average fitness per generation, diversity metrics) potentially to console or its own log files, or by publishing specific `ga.progress.v1` events via the Orchestration Layer.

---

## 5. Data Management & State

*   **Persistent State:**
    *   Populations of genomes at each generation (can be saved to files like Pickle, JSON, CSV to allow resuming evolution or analyzing history).
    *   Fitness scores for all evaluated individuals.
    *   Configuration of the Genetic Algorithm run itself.
    *   Logs detailing the evolutionary process (e.g., best individuals, parameter changes).
*   **In-Memory State:**
    *   Current population of genomes.
    *   Fitness scores for the current generation being evaluated.
    *   Internal state of Genetic Algorithm operators.

---

## 6. Scalability & Performance Considerations

*   **Computational Cost:** Evolutionary runs are typically very computationally expensive due to the large number of simulation evaluations required.
*   **Parallel Fitness Evaluations:** Success heavily depends on the Experiment Management System and Go Orchestration Layer's ability to efficiently run multiple Rust Simulation Worker instances in parallel.
*   **Efficient Fitness Calculation:** The analysis scripts used by the Statistical Interpretation / Analysis Layer for fitness calculation must be optimized to quickly process logged data.
*   **Bottlenecks:**
    *   Waiting for all simulation runs in a generation to complete.
    *   Processing potentially large volumes of log data for fitness scores.
*   **Strategies for Scaling:**
    *   Maximize parallel execution of simulation runs.
    *   (Future Beta) Distributed Genetic Algorithms (e.g., island models with migration).

---

## 7. Testing Strategy (Aligned with Alpha Roadmap `a0.9.Y.Z`)

*   **Unit Tests (`a0.9.1t` - `a0.9.3t`):**
    *   Genome representation and genome-to-agent-config translation.
    *   Individual Genetic Algorithm operators (selection, mutation, crossover) with known inputs/outputs.
    *   Fitness function interface logic (using mock simulation outcome data).
*   **Integration Tests (Intra-layer - part of `a0.9.4t`):**
    *   Test a full Genetic Algorithm loop for a few generations on a very simple, fast-to-evaluate mathematical fitness function (not a full simulation) to verify the mechanics.
*   **Integration Tests (Inter-layer via Mocks/Stubs - `a0.9.2t`):**
    *   Test interaction with a mock Experiment Management System (verify correct submission of evaluation jobs/configurations).
    *   Test interaction with a mock Statistical Interpretation / Analysis Layer (provide mock fitness scores based on `simulation_id`s).
*   **End-to-End Test (Simple Evolutionary Run - `a0.9.4.Z`):**
    *   Run a short evolutionary process with a very simple simulation task and fitness goal (e.g., evolve agents to maximize lifespan or energy gathered).
    *   Verify the pipeline: AES -> EMS -> Orchestration Layer -> Simulation Layer -> Logging Layer -> Analysis Layer (for fitness) -> AES.
    *   Observe if any trend (even slight) in average fitness occurs over generations.

---

## 8. Future Enhancements / Open Questions

*   **More Sophisticated Evolutionary Algorithms:**
    *   Neuroevolution (e.g., NEAT, HyperNEAT) for evolving Neural Network topologies directly.
    *   Co-evolution (e.g., predator-prey arms races).
    *   Multi-objective optimization.
*   **Interactive Evolution.**
*   **Speciation / Niching techniques.**
*   **Robust storage and browsing for evolutionary lineages and archives of evolved genomes.**
*   **How to effectively evolve parameters for DRL agents trained in the Agent Intelligence Layer?** (e.g., evolving learning rates, discount factors, exploration strategies, or even parts of the NN architecture).

---

## Alpha Roadmap Version Breakdown for Agent Evolution System Development:

This section explicitly lists the tasks from the main Alpha Roadmap (`alpha.md`) that pertain to the development and integration of the Agent Evolution System.

*   **`a0.1.Y.Z`: Configuration Management System (Python UI) - Basic Editor**
    *   (Produces YAML configuration files that will define parameters for the AES and base agent configurations).
*   **`a0.6.Y.Z`: Experiment Management System - Basic CLI/Scripting for Batch Runs**
    *   (The AES will use this system to run its simulation-based fitness evaluations).
*   **`a0.7.Y.Z`: Logging Layer (Python) - Integrated Event Capture to Parquet**
    *   (Produces the Apache Parquet log data that the AES will (indirectly, via Analysis Layer) use for fitness calculation).
*   **`a0.9.Y.Z`: Evolution Engine (Python) - Basic Genome & Fitness Evaluation Loop**
    *   `a0.9.1.Z`: Define Basic Genome Structure & Agent Configuration Mapping
        *   (`a0.9.1.1t` & `a0.9.1.1` through `a0.9.1.2t` & `a0.9.1.2` as detailed previously)
    *   `a0.9.2.Z`: Population Management & Fitness Evaluation Orchestration
        *   (`a0.9.2.1t` & `a0.9.2.1` through `a0.9.2.3t` & `a0.9.2.3` as detailed previously)
    *   `a0.9.3.Z`: Implement Basic Evolutionary Operators
        *   (`a0.9.3.1t` & `a0.9.3.1` through `a0.9.3.3t` & `a0.9.3.3` as detailed previously)
    *   `a0.9.4.Z`: Basic Generational Loop & Integration Test
        *   (`a0.9.4.1t` & `a0.9.4.1` through `a0.9.4.2t` & `a0.9.4.2` as detailed previously)

---